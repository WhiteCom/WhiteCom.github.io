---
layout: single
title: "C++ std::cin 입력버퍼 비우기"
date: 2026-03-02
categories: [Computer-Language]
tags: [C++]
toc: true
toc_sticky: true
---

코딩테스트 문제의 경우, 다른사람들 풀이를 볼 경우, cin.ignore() 사용하는 경우가 많다. 이 때 해당 코드의 의미가 뭘까?

먼저 아래 코드를 살펴보자.

```cpp
#include <iostream>
#include <string>

int main()
{
	int n;
	std::cin >> n;

	std::string s;
	std::cin >> s;

	std::string s2;
	std::getline(std::cin, s2);

	std::cout << "\n========================\n";
	std::cout << n << '\n';
	std::cout << s << '\n';
	std::cout << s2 << '\n';
	return 0;
}
```

위 예제코드를 실행시키면, 중수, 문자열 1, 문자열 2 순서대로 나와야 할 것으로 추측된다. 

하지만 실제로 코드를 실행하면 다음과 같다. 
![Test Result 01](/assets/images/2026-03-02-Cpp_info_01/Test01.webp)

위와 같은 결과가 나오는 이유는 표준입출력에 대한 입력 버퍼에 대한 이해가 있어야 한다.

- std::cin 의 경우 개행문자 '\n' 을 처리하지 않고 입력버퍼에 남겨둔다.
- std::getline의 경우 개행문자 '\n'을 입력버퍼에서 가져와서 처리한다. 따라서 s2에 '\n'가 전달되며 '\n' 제거 후 s2에 빈 문자('')를 담기 때문에 빈 문자를 출력 후 종료된다. 

이런 현상을 막기위해 std::cin.ignore() 를 사전에 사용해야 한다. 

```cpp
#include <iostream>
#include <string>

int main()
{
	int n;
	std::cin >> n;

	std::string s;
	std::cin >> s;

	std::cin.ignore();
	std::string s2;
	std::getline(std::cin, s2);

	std::cout << "\n========================\n";
	std::cout << "n : " << n << '\n';
	std::cout << "s : " << s << '\n';
	std::cout << "s2 : " << s2 << '\n';
	return 0;
}
```

![Test Result 02](/assets/images/2026-03-02-Cpp_info_01/Test02.webp)

여기서 cin.ignore() 위치를 바꿔보자.

* 1번째 위치 변경

```cpp
#include <iostream>
#include <string>

int main()
{
	std::cin.ignore(); // 1번째 코드위치
	int n;
	std::cin >> n;

	std::string s;
	std::cin >> s;
	
	std::string s2;
	std::getline(std::cin, s2);

	std::cout << "\n========================\n";
	std::cout << "n : " << n << '\n';
	std::cout << "s : " << s << '\n';
	std::cout << "s2 : " << s2 << '\n';
	return 0;
}
```

![Test Result 03](/assets/images/2026-03-02-Cpp_info_01/Test03.webp)


* 2번째 위치 변경

```cpp
#include <iostream>
#include <string>

int main()
{
	int n;
	std::cin >> n;

	std::cin.ignore(); // 2번째 코드위치
	std::string s;
	std::cin >> s;
	
	std::string s2;
	std::getline(std::cin, s2);

	std::cout << "\n========================\n";
	std::cout << "n : " << n << '\n';
	std::cout << "s : " << s << '\n';
	std::cout << "s2 : " << s2 << '\n';
	return 0;
}
```

![Test Result 04](/assets/images/2026-03-02-Cpp_info_01/Test04.webp)


* 3번째 위치 변경

```cpp
#include <iostream>
#include <string>

int main()
{
	int n;
	std::cin >> n;

	std::string s;
	std::cin >> s;
	
	std::cin.ignore(); // 3번째 코드위치
	std::string s2;
	std::getline(std::cin, s2);

	std::cout << "\n========================\n";
	std::cout << "n : " << n << '\n';
	std::cout << "s : " << s << '\n';
	std::cout << "s2 : " << s2 << '\n';
	return 0;
}
```

![Test Result 05](/assets/images/2026-03-02-Cpp_info_01/Test05.webp)

이번엔 모든 문자열입력에 대해 모두 getline으로 변경한 뒤, 1, 2, 3번째 위치에 cin.ignore위치를 옮겨보았다. 

* 1번째 위치

```cpp
#include <iostream>
#include <string>

int main()
{
	std::cin.ignore(); // 1번째 위치
	int n;
	std::cin >> n;

	std::string s;
	std::cin >> s;
	
	std::string s2;
	std::getline(std::cin, s2);

	std::cout << "\n========================\n";
	std::cout << "n : " << n << '\n';
	std::cout << "s : " << s << '\n';
	std::cout << "s2 : " << s2 << '\n';
	return 0;
}
```

![Test Result 06](/assets/images/2026-03-02-Cpp_info_01/Test06.webp)

* 2번째 위치

```cpp
#include <iostream>
#include <string>

int main()
{
	int n;
	std::cin >> n;

	std::cin.ignore(); // 2번째 위치
	std::string s;
	std::cin >> s;
	
	std::string s2;
	std::getline(std::cin, s2);

	std::cout << "\n========================\n";
	std::cout << "n : " << n << '\n';
	std::cout << "s : " << s << '\n';
	std::cout << "s2 : " << s2 << '\n';
	return 0;
}
```
![Test Result 07](/assets/images/2026-03-02-Cpp_info_01/Test07.webp)


* 3번째 위치

```cpp
#include <iostream>
#include <string>

int main()
{
	int n;
	std::cin >> n;

	std::string s;
	std::cin >> s;
	
	std::cin.ignore(); // 3번째 위치
	std::string s2;
	std::getline(std::cin, s2);

	std::cout << "\n========================\n";
	std::cout << "n : " << n << '\n';
	std::cout << "s : " << s << '\n';
	std::cout << "s2 : " << s2 << '\n';
	return 0;
}
```

![Test Result 08](/assets/images/2026-03-02-Cpp_info_01/Test08.webp)


이번엔 다른예제로 확인해보자. 

```cpp
#include <iostream>
#include <string>
#include <vector>

int main()
{
	int n;
	std::cin >> n;
	std::vector<std::string> vecStr;

	for (int i = 0; i < n; ++i)
	{
		std::string s;
		std::getline(std::cin, s);
		vecStr.push_back(s);
	}
	
	std::cout << "\n========================\n";
	for (int i = 0; i < vecStr.size(); ++i)
	{
		std::cout << i << " : " << vecStr[i] << '\n';
	}
	
	return 0;
}
```
![Test Result 09](/assets/images/2026-03-02-Cpp_info_01/Test09.webp)


다음은 cin.ignore() 를 추가한 후 결과물을 보자.

```cpp
#include <iostream>
#include <string>
#include <vector>

int main()
{
	int n;
	std::cin >> n;
	std::vector<std::string> vecStr;

	std::cin.ignore();
	for (int i = 0; i < n; ++i)
	{
		std::string s;
		std::getline(std::cin, s);
		vecStr.push_back(s);
	}
	
	std::cout << "\n========================\n";
	for (int i = 0; i < vecStr.size(); ++i)
	{
		std::cout << i << " : " << vecStr[i] << '\n';
	}
	
	return 0;
}
```

![Test Result 10](/assets/images/2026-03-02-Cpp_info_01/Test10.webp)


* 결론

- 테스트 결과, getline 으로 한 줄씩 입력을 받는 경우, 사전에 cin.ignore() 를 이용해 입력버퍼를 비워주는 작업이 필요한 것으로 결론을 낼 수 있었다.